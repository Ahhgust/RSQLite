#' @include Connection.R
#' @include Driver.R
NULL

#' Connect to an SQLite datbase
#' 
#' Together, \code{SQLite()} and \code{dbConnect()} allow you to connect to
#' a SQLite database file.
#' 
#' @export
#' @param ... In previous versions, \code{SQLite()} took arguments. These
#'   have now all been moved to \code{dbConnect()}, and any arguments here
#'   will be ignored with a warning.
#' @import methods DBI
SQLite <- function(...) {
  if (nargs() > 0) {
    warning("All arguments to RSQLite Driver are ignored.", call. = FALSE)
  }
  new("SQLiteDriver")
}

#' @export
SQLITE_RWC <- 6L
#' @export
SQLITE_RW <- 2L
#' @export
SQLITE_RO <- 1L

#' @param drv,conn An objected generated by \code{\link{SQLite}}, or an existing
#'   \code{\linkS4class{SQLiteConnection}}. If an connection, the connection 
#'   will be cloned.
#' @param dbname The path to the database file. SQLite keeps each database
#'   instance in one single file. The name of the database \emph{is} the file
#'   name, thus database names should be legal file names in the running
#'   platform. There are two exceptions:
#'   
#'   \itemize{ 
#'   \item \code{""} will create a temporary on-disk database. The file
#'     will be deleted when the connection is closed. 
#'   \item \code{":memory:"} will create a temporary in-memory database. 
#'   }
#' @param cache_size Advanced option. A positive integer to change the maximum 
#'   number of disk pages that SQLite holds in memory (SQLite's default is 
#'   2000 pages). See \url{http://www.sqlite.org/pragma.html#pragma_cache_size} 
#'   for details.
#' @param synchronous Advanced options. Possible values for \code{synchronous} 
#'   are "off" (the default), "normal", or  "full".  Users have reported 
#'   significant speed ups using \code{sychronous = "off"}, and the SQLite 
#'   documentation itself implies considerable improved performance at the very 
#'   modest risk of database corruption in the unlikely case of the operating 
#'   system (\emph{not} the R application) crashing. See
#'   \url{http://www.sqlite.org/pragma.html#pragma_synchronous} for details.
#' @param flags \code{SQLITE_RWC}: open the database in read/write mode
#'   and create the database file if it does not already exist; 
#'   \code{SQLITE_RW}: open the database in read/write mode. Raise an error 
#'   if the file does not already exist; \code{SQLITE_RO}: open the database in 
#'   read only mode.  Raise an error if the file does not already exist
#' @param loadable.extensions When \code{TRUE} (default) SQLite3
#'   loadable extensions are enabled. Setting this value to \code{FALSE}
#'   prevents extensions from being loaded.
#' @param vfs Select the SQLite3 OS interface. See
#'   \url{http://www.sqlite.org/vfs.html} for details. Allowed values are
#'   \code{"unix-posix"}, \code{"unix-unix-afp"},
#'   \code{"unix-unix-flock"}, \code{"unix-dotfile"}, and
#'   \code{"unix-none"}.
#' @aliases SQLITE_RWC SQLITE_RW SQLITE_RO
#' @export
#' @rdname SQLite
#' @examples
#' # Initialize a temporary in memory database and copy a data.frame into it
#' con <- dbConnect(RSQLite::SQLite(), ":memory:")
#' data(USArrests)
#' dbWriteTable(con, "USArrests", USArrests)
#' dbListTables(con)
#' 
#' # Fetch all query results into a data frame:
#' dbGetQuery(con, "SELECT * FROM USArrests")
#' 
#' # Or do it in batches
#' rs <- dbSendQuery(con, "SELECT * FROM USArrests")
#' d1 <- fetch(rs, n = 10)      # extract data in chunks of 10 rows
#' dbHasCompleted(rs)
#' d2 <- fetch(rs, n = -1)      # extract all remaining data
#' dbHasCompleted(rs)
#' dbClearResult(rs)
#' 
#' # clean up
#' dbDisconnect(con)
setMethod("dbConnect", "SQLiteDriver",
  function(drv, dbname = "", loadable.extensions = TRUE, cache_size = NULL, 
           synchronous = "off", flags = SQLITE_RWC, vfs = NULL) {
    dbname <- path.expand(dbname)
    
    stopifnot(length(dbname) == 1, !is.na(dbname))
    
    vfs <- check_vfs(vfs)
    stopifnot(is.integer(flags), length(flags) == 1)

    con <- new("SQLiteConnection", 
      ptr = rsqlite_connect(dbname, loadable.extensions, flags, vfs),
      dbname = dbname,
      flags = flags,
      vfs = vfs,
      loadable.extensions = loadable.extensions
    )
    
    ## experimental PRAGMAs
    if (!is.null(cache_size)) {
      cache_size <- as.integer(cache_size)
      try(dbGetQuery(con, sprintf("PRAGMA cache_size=%d", cache_size)))
    }
    
    if (!is.null(synchronous)) {
      synchronous <- match.arg(synchronous, c("off", "normal", "full"))
      try(dbGetQuery(con, sprintf("PRAGMA synchronous=%s", synchronous)))
    }
    
    con
  }
)

check_vfs <- function(vfs) {
  if (is.null(vfs) || vfs == "") return("")
  
  if (.Platform[["OS.type"]] == "windows") {
    warning("vfs customization not available on this platform.",
      " Ignoring value: vfs = ", vfs, call. = FALSE)
    return("")
  }

  match.arg(vfs, c("unix-posix", "unix-afp", "unix-flock", "unix-dotfile",
    "unix-none"))
}

#' @export
#' @rdname SQLite
setMethod("dbConnect", "SQLiteConnection", function(drv){
  if (drv@dbname %in% c("", ":memory:")) {
    stop("Can't clone a temporary database", call. = FALSE)
  }
  
  dbConnect(SQLite(), drv@dbname, vfs = drv@vfs, flags = drv@flags, 
    loadable.extensions = drv@loadable.extensions)
})


#' @export
#' @rdname SQLite
setMethod("dbDisconnect", "SQLiteConnection", function(conn) {
  rsqlite_disconnect(conn@ptr)
  invisible(TRUE)
})
